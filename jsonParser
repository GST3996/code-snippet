import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.datastream.ConnectedStreams;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.co.CoProcessFunction;
import org.apache.flink.util.Collector;

public class FlinkFilteredJoinJsonStreams {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // User JSON Stream
        DataStream<String> userStream = env.fromElements(
                "{\"id\": 1, \"name\": \"Alice\", \"age\": 25}",
                "{\"id\": 2, \"name\": \"Bob\", \"age\": 30}",
                "{\"id\": 3, \"name\": \"Charlie\", \"age\": 35}"
        );

        // Order JSON Stream
        DataStream<String> orderStream = env.fromElements(
                "{\"orderId\": 101, \"userId\": 1, \"amount\": 250.75}",
                "{\"orderId\": 102, \"userId\": 2, \"amount\": 99.99}",
                "{\"orderId\": 103, \"userId\": 3, \"amount\": 150.00}"
        );

        // Connect user and order streams
        ConnectedStreams<String, String> connectedStreams = userStream.connect(orderStream);

        // Process and merge based on ID
        DataStream<String> mergedStream = connectedStreams.process(new FilteredUserOrderJoinFunction());

        // Print the final merged output
        mergedStream.print("Merged Stream");

        env.execute("Flink Filtered JSON Join");
    }

    public static class FilteredUserOrderJoinFunction extends CoProcessFunction<String, String, String> {
        private transient ValueState<String> userState;
        private transient ValueState<String> orderState;
        private static final ObjectMapper objectMapper = new ObjectMapper();

        @Override
        public void open(Configuration parameters) {
            userState = getRuntimeContext().getState(new ValueStateDescriptor<>("userState", String.class));
            orderState = getRuntimeContext().getState(new ValueStateDescriptor<>("orderState", String.class));
        }

        @Override
        public void processElement1(String userJson, Context ctx, Collector<String> out) throws Exception {
            JsonNode userNode = objectMapper.readTree(userJson);
            int userId = userNode.get("id").asInt(); // Extract user ID

            String orderJson = orderState.value();
            if (orderJson != null) {
                // Both user and order exist, merge them
                out.collect(mergeJson(userNode, orderJson));
                orderState.clear();
            } else {
                // Store user data until order arrives
                userState.update(userJson);
            }
        }

        @Override
        public void processElement2(String orderJson, Context ctx, Collector<String> out) throws Exception {
            JsonNode orderNode = objectMapper.readTree(orderJson);
            int userId = orderNode.get("userId").asInt(); // Extract user ID

            String userJson = userState.value();
            if (userJson != null) {
                // Both user and order exist, merge them
                out.collect(mergeJson(objectMapper.readTree(userJson), orderJson));
                userState.clear();
            } else {
                // Store order data until user arrives
                orderState.update(orderJson);
            }
        }

        private String mergeJson(JsonNode userNode, String orderJson) throws Exception {
            ObjectNode merged = (ObjectNode) objectMapper.readTree(orderJson);
            merged.put("name", userNode.get("name").asText()); // Add only "name" from user JSON
            return objectMapper.writeValueAsString(merged);
        }
    }
}
